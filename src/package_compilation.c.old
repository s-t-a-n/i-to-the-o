/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   package_compilation.c                              :+:    :+:            */
/*                                                     +:+                    */
/*   By: sverschu <sverschu@student.codam.n>          +#+                     */
/*                                                   +#+                      */
/*   Created: 2020/02/25 18:58:07 by sverschu      #+#    #+#                 */
/*   Updated: 2020/02/27 00:31:00 by sverschu      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "ito_internal.h"

/*
   static int	conv_int_to_ucharstr(t_buffer *buffer, signed int var)
   {
   if ((buffer->len = snprintf(NULL, 0, "%i", var)))
   {
   if ((buffer->mem = (char *)malloc(buffer->len + 1)))
   {
   if (snprintf(buffer->mem, buffer->len, "%i", var) != buffer->len)
   free(buffer->mem);
   else
   return (0);
   }
   }
   return (1);
   }
   */

static int	int_snprintf(char *str, size_t size, void *var)
{
	return(snprintf(dst, size, "%i",(int)*var));
}

static int	add_datatype_to_package(int *f_type_snprintf, void *var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = f_snprintf(NULL, 0, formatstr, &var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, formatstr, var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s%s%s : %s\n","add_", formatstr, "_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_datatype_to_package(type, formatstr, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}

//make this a macro

static int	add_int_to_package(signed int var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = snprintf(NULL, 0, "%i", var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, "%i", var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s : %s\n","add_[data]_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_int_to_package(var, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}


static int	add_uint_to_package(unsigned int var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = snprintf(NULL, 0, "%u", var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, "%u", var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s : %s\n","add_[data]_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_uint_to_package(var, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}

static int	add_ulong_to_package(unsigned long var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = snprintf(NULL, 0, "%lu", var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, "%lu", var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s : %s\n","add_[data]_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_ulong_to_package(var, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}
static int	add_double_to_package(double var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = snprintf(NULL, 0, "%f", var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, "%f", var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s : %s\n","add_[data]_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_double_to_package(var, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}

static int	add_string_to_package(char *var, t_package *package)
{
	int		len;
	unsigned char	*mem_p_cmp;

	len = snprintf(NULL, 0, "%s", var) + 1;
	if (len > 0)
	{
		if (package->index + len < package->mem_cap)
		{
			package->index += snprintf((char *)&package->mem[package->index], len, "%s", var) + 1;
			(package->elem_count)++;
		}
		else if ((package->mem_cap *= 2) < MEMCAP_MAX)
		{
			LOG_DEBUG("%s : %s\n","add_[data]_to_package", "reallocing package->mem");
			mem_p_cmp = (unsigned char *)realloc(package->mem, package->mem_cap);
			if (mem_p_cmp && mem_p_cmp != package->mem)
			{
				package->mem = mem_p_cmp;
				return(add_string_to_package(var, package));
			}
			else
			{
				free(mem_p_cmp);
				handle_error("add_[data]_to_package", "realloc failure!", NULL, ERR_WARN);
			}
		}
		else
		{
			handle_error("add_[data]_to_package", "MEMCAP_MAX exceeded!", NULL, ERR_WARN);
			return (ITO_ERROR);
		}
	}
	else
	{
		handle_error("add_[data]_to_package", "zero data length!", NULL, ERR_WARN);
		return (ITO_ERROR);
	}
	return (ITO_SUCCESS);
}

int		add_data_to_package(va_list *args, const char * restrict formatstr,
		t_package *package)
{
	switch(*formatstr)
	{
		case 'i':
			LOG_DEBUG("%s : %s\n","add_data_to_package", "adding SIGNED INT to package");
			return(add_int_to_package(va_arg(*args, signed int), package));
			break;
		case 'd':
			LOG_DEBUG("%s : %s\n","add_data_to_package", "adding SIGNED INT to package");
			return(add_int_to_package(va_arg(*args, signed int), package));
			break;
		case 'u':
			LOG_DEBUG("%s : %s\n","add_data_to_package", "adding UNSIGNED INT to package");
			return(add_uint_to_package(va_arg(*args, unsigned int), package));
			break;
		case 'f':
			LOG_DEBUG("%s : %s\n","add_data_to_package", "adding DOUBLE to package");
			return(add_double_to_package(va_arg(*args, double), package));
			break;
		case 's':
			LOG_DEBUG("%s : %s\n","add_data_to_package", "adding STRING to package");
			return(add_string_to_package(va_arg(*args, char *), package));
			break;
		case 'l':
			if (*(formatstr + 1) == 'i')
			{
				LOG_DEBUG("%s : %s\n","add_data_to_package", "adding SIGNED LONG to package");
			}
			else if (*(formatstr + 1) == 'u')
			{
				LOG_DEBUG("%s : %s\n","add_data_to_package", "adding UNSIGNED LONG to package");
			return(add_ulong_to_package(va_arg(*args, unsigned long), package));

			}
			else if (*(formatstr + 1) == 'f')
			{
				LOG_DEBUG("%s : %s\n","add_data_to_package", "adding LONG DOUBLE to package");

			}
			break;
		default:
			handle_error("handle_conversion", "unknown conversion specifier",
					NULL, ERR_CRIT);
			return (ITO_ERROR);
	}
	return (ITO_ERROR);
}
